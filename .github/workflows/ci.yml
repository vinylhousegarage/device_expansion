name: CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      # リモートリポジトリをチェックアウト
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # 実行中のユーザーを確認
      - name: Check current user
        run: whoami

      # ls -ld コマンドを実行して、ディレクトリの所有者とパーミッションを確認
      - name: Check directory permissions and ownership
        run: ls -ld /home/runner/work/device_expansion/device_expansion

      # ディレクトリ内のパーミッションの確認
      - name: Check permissions of all files
        run: ls -lR /home/runner/work/device_expansion/device_expansion

      # GHCR にログイン
      - name: Log in to GitHub Container Registry
        run: |
          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      # GHCRから既存のDockerイメージをプルしてキャッシュとして使用
      - name: Pull Docker image from GHCR
        run: docker pull ghcr.io/vinylhousegarage/device_expansion:latest || echo "No cached image found, continuing with fresh build"

      # Dockerイメージ に差分があるコミットを commit_list.txt に抽出
      # commit_list.txt のコミットIDを1行ずつ読み取り GHCR にビルドしプッシュ
      # 最新のコミットを変数LATEST_COMMIT に格納
      # 変数LATEST_COMMIT が空ではないか確認
      # 最新のDockerイメージに latest のタグを付けGHCRにビルドしプッシュ
      - name: Get commits with Dockerfile or compose.yaml changes and process each commit
        run: |
          git log --reverse --pretty=format:"%H" $HEAD -- Dockerfile compose.yaml > commit_list.txt
          if [ ! -s commit_list.txt ]; then
            echo "No commits with Dockerfile or compose.yaml changes found."
            exit 0
          fi

          set -e
          echo "Commits to process: $(cat commit_list.txt)"
          while IFS= read -r COMMIT; do
            echo "Processing commit: $COMMIT with message: $(git log -1 --pretty=%B $COMMIT)"
            docker build --cache-from ghcr.io/vinylhousegarage/device_expansion:latest \
            -t ghcr.io/vinylhousegarage/device_expansion:$COMMIT .
            docker push ghcr.io/vinylhousegarage/device_expansion:$COMMIT
            LATEST_COMMIT=$COMMIT
          done < commit_list.txt

          if [[ -n "$LATEST_COMMIT" ]]; then
            docker tag ghcr.io/vinylhousegarage/device_expansion:$LATEST_COMMIT ghcr.io/vinylhousegarage/device_expansion:latest
            docker push ghcr.io/vinylhousegarage/device_expansion:latest
          fi

      # Ruby をセットアップ
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1.0

      # Gem のキャッシュを利用してビルドを高速化
      - name: Cache gems
        uses: actions/cache@v3
        with:
          path: vendor/bundle
          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}-v1
            ${{ runner.os }}-gems-v1

      # PostgreSQL 関連のライブラリと gem をインストール
      - name: Install dependencies
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y libpq-dev || echo "Failed to install libpq-dev"
          bundle config set path 'vendor/bundle'
          bundle install --jobs 4 --retry 3

      # RuboCop を実行してコードスタイルを検証
      - name: Run RuboCop (Lint check)
        run: bundle exec rubocop --config .rubocop.yml --fail-level W

      # PostgreSQL と postgresql-client を 14 でインストール
      - name: Install PostgreSQL 14 and client tools
        run: |
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          sudo apt-get update
          sudo apt-get install -y postgresql-14 postgresql-client-14
          sudo service postgresql start

      # 最大60秒間 PostgreSQL の応答を確認
      - name: Wait for PostgreSQL to be ready
        run: |
          for i in {1..12}; do
            if pg_isready -h localhost -p 5432; then
              echo "PostgreSQL is ready!"
              exit 0
            fi
            echo "Waiting for PostgreSQL to be ready... Attempt $i at $(date)"
            sleep 5
          done
          echo "PostgreSQL did not become ready in time."
          exit 1

      # ユーザーロールをセットアップ
      - name: Set up pg_role
        run: |
          if ! sudo -u postgres psql -tc "SELECT 1 FROM pg_roles WHERE rolname='${{ secrets.POSTGRES_USER }}'" | grep -q 1; then
            sudo -u postgres psql -c "CREATE USER ${{ secrets.POSTGRES_USER }} WITH PASSWORD '${{ secrets.POSTGRES_PASSWORD }}';" || exit 1
          fi

      # スーパーユーザー権限を付与
      - name: Grant superuser privileges to the PostgreSQL user
        run: |
          if ! sudo -u postgres psql -tc "SELECT rolsuper FROM pg_roles WHERE rolname = '${{ secrets.POSTGRES_USER }}' AND rolsuper = 't'" | grep -q 1; then
            sudo -u postgres psql -c "ALTER USER ${{ secrets.POSTGRES_USER }} WITH SUPERUSER;" || exit 1
          fi

      # データベースの有無を確認
      - name: List all databases with expanded output
        run: |
          echo "Listing all databases in expanded mode:"
          sudo -u postgres psql -c "\l"

      # デーベースの名前を確認
      - name: List all database names
        run: |
          echo "Listing all database names in PostgreSQL:"
          sudo -u postgres psql -c "SELECT datname FROM pg_database;"

      # POSTGRES_DB を生成
      - name: Run database create
        env:
          TEST_DB: postgres_db
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:create RAILS_ENV=test

      # POSTGRES_DB の生成を確認
      - name: List all databases with expanded output
        run: |
          echo "Listing all databases in expanded mode:"
          sudo -u postgres psql -c "\l"

      # POSTGRES_DB をマイグレート
      - name: Run database migrations
        env:
          TEST_DB: postgres_db
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:migrate RAILS_ENV=test

      # マイグレーション履歴を確認
      - name: Check applied migrations
        run: |
          echo "Checking applied migrations..."
          sudo -u postgres psql -d postgres_db -c "SELECT * FROM schema_migrations;"

      # マイグレートした POSTGRES_DB に初期データを挿入
      - name: Run Seed the test database
        env:
          TEST_DB: postgres_db
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:seed RAILS_ENV=test

      # 初期データ挿入の成否を確認
      - name: Check if seed data was inserted
        run: |
          echo "Checking if users are inserted into the test database..."
          user_count=$(sudo -u postgres psql -d postgres_db -tAc "SELECT COUNT(*) FROM users;")
          if [ "$user_count" -eq 0 ]; then
            echo "Error: No users found in the test database. Seed data was not inserted correctly."
            exit 1
          else
            echo "Seed data successfully inserted: $user_count users found."
          fi

      # bin/rails への実行権限を付与
      - name: Grant execute permission to bin/rails
        run: chmod +x bin/rails

      # ルーティングを確認
      - name: Run Rails routes to check routing
        env:
          RAILS_ENV: test
        run: bin/rails routes

      # テストを実行
      - name: Run tests
        env:
          TEST_DB: postgres_db
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          RAILS_ENV: test
        run: bundle exec rails test

      # Node.js と Yarn の環境を構築
      - name: Install Node.js and Yarn
        uses: actions/setup-node@v2
        with:
          node-version: '18.20.4'

      # Yarn をインストール
      - name: Install Yarn
        run: npm install -g yarn@1.22.22

      # Yarn の依存関係をインストール
      - name: Install Yarn dependencies
        run: yarn install

      # Hotwire の turbo と stimulus をインストール
      - name: Install Hotwire dependencies
        run: |
          yarn add @hotwired/turbo
          yarn add @hotwired/stimulus

      # Gemfile に基づいて Railsのgem をインストール
      - name: Install Rails gems
        run: bundle install

      # アセットのプリコンパイルを実行
      - name: Precompile assets for production
        env:
          RAILS_ENV: production
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: bundle exec rails assets:precompile

  deploy:
    runs-on: ubuntu-latest
    needs: build
    env:
      RAILS_ENV: production

    steps:
      # リモートリポジトリをチェックアウト
      - name: Check out the repository
        uses: actions/checkout@v3

      # jqをインストール
      - name: Install jq
        run: sudo apt-get install -y jq

      # Render で bundle installジョブを実行
      # Render APIから bundle install のデータを取得
      # 変数BUNDLE_INSTALL_JOB_RESPONSE が空ではないか確認
      # bundle install ID を取得
      # 変数BUNDLE_INSTALL_ID が空ではないか確認
      # 最大180回を bundle install ID情報の取得を反復
      # Render API から bundle install ID情報を取得
      # 変数BUNDLE_INSTALL_ID_RESPONSE が空ではないか確認
      # bundle install のステータスを取得
      # bundle install のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run bundle install
        env:
          RAILS_ENV: production
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          BUNDLE_INSTALL_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "bundle install"
            }')

            if [[ -z "$BUNDLE_INSTALL_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve creating bundle install job information"
              exit 1
            fi

            echo "$BUNDLE_INSTALL_JOB_RESPONSE" | jq '.'

            BUNDLE_INSTALL_ID=$(echo "$BUNDLE_INSTALL_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$BUNDLE_INSTALL_ID" ]]; then
            echo "Failed to retrieve bundle-install-id information"
            exit 1
          fi

          echo "$BUNDLE_INSTALL_ID"

          for i in {1..180}; do
            BUNDLE_INSTALL_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$BUNDLE_INSTALL_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$BUNDLE_INSTALL_ID_RESPONSE" ]]; then
              echo "Failed to retrieve running bundle install information"
              exit 1
            fi

            echo "$BUNDLE_INSTALL_ID_RESPONSE" | jq '.'

            BUNDLE_INSTALL_STATUS=$(echo "$BUNDLE_INSTALL_ID_RESPONSE" | jq -r '.status')

            if [[ "$BUNDLE_INSTALL_STATUS" == "succeeded" ]]; then
              echo "bundle install succeeded"
              exit 0
            elif [[ "$BUNDLE_INSTALL_STATUS" == "failed" ]]; then
              echo "bundle install failed"
              exit 1
            else
              echo "Waiting for bundle install to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "bundle install is still in progress after 30 minutes. Exiting."
          echo "Final bundle install Status: $BUNDLE_INSTALL_STATUS"
          exit 1

      # Render で Yarn のインストールジョブを実行
      # Render APIから yarn-installデータを取得
      # 変数YARN_INSTALL_JOB_RESPONSE が空ではないか確認
      # yarn-install ID を取得
      # 変数YARN_INSTALL_ID が空ではないか確認
      # 最大180回を yarn-install ID情報の取得を反復
      # Render API から yarn-install ID情報を取得
      # 変数YARN_INSTALL_ID_RESPONSE が空ではないか確認
      # yarn-install のステータスを取得
      # yarn-install のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Install dependencies
        env:
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          YARN_INSTALL_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "yarn install"
            }')

            if [[ -z "$YARN_INSTALL_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve yarn install job information"
              exit 1
            fi

            echo "$YARN_INSTALL_JOB_RESPONSE" | jq '.'

            YARN_INSTALL_ID=$(echo "$YARN_INSTALL_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$YARN_INSTALL_ID" ]]; then
            echo "Failed to retrieve yarn-install-id information"
            exit 1
          fi

          echo "$YARN_INSTALL_ID"

          for i in {1..180}; do
            YARN_INSTALL_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$YARN_INSTALL_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$YARN_INSTALL_ID_RESPONSE" ]]; then
              echo "Failed to retrieve yarn install information"
              exit 1
            fi

            echo "$YARN_INSTALL_ID_RESPONSE" | jq '.'

            YARN_INSTALL_STATUS=$(echo "$YARN_INSTALL_ID_RESPONSE" | jq -r '.status')

            if [[ "$YARN_INSTALL_STATUS" == "succeeded" ]]; then
              echo "yarn install succeeded"
              exit 0
            elif [[ "$YARN_INSTALL_STATUS" == "failed" ]]; then
              echo "yarn install failed"
              exit 1
            else
              echo "Waiting for yarn install to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "yarn install is still in progress after 30 minutes. Exiting."
          echo "Final yarn install Status: $ARN_INSTALL_STATUS"
          exit 1

      # Render で esbuild のインストールジョブを実行
      # Render APIから esbuild-installデータを取得
      # 変数ESBUILD_INSTALL_JOB_RESPONSE が空ではないか確認
      # esbuild-install ID を取得
      # 変数ESBUILD_INSTALL_ID が空ではないか確認
      # 最大180回を esbuild-install ID情報の取得を反復
      # Render API から esbuild-install ID情報を取得
      # 変数ESBUILD_INSTALL_ID_RESPONSE が空ではないか確認
      # esbuild-install のステータスを取得
      # esbuild-install のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Add esbuild
        env:
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          ESBUILD_INSTALL_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "yarn add esbuild"
            }')

            if [[ -z "$ESBUILD_INSTALL_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve esbuild install job information"
              exit 1
            fi

            echo "$ESBUILD_INSTALL_JOB_RESPONSE" | jq '.'

            ESBUILD_INSTALL_ID=$(echo "$ESBUILD_INSTALL_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$ESBUILD_INSTALL_ID" ]]; then
            echo "Failed to retrieve esbuild-install-id information"
            exit 1
          fi

          echo "$ESBUILD_INSTALL_ID"

          for i in {1..180}; do
            ESBUILD_INSTALL_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$ESBUILD_INSTALL_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$ESBUILD_INSTALL_ID_RESPONSE" ]]; then
              echo "Failed to retrieve esbuild install information"
              exit 1
            fi

            echo "$ESBUILD_INSTALL_ID_RESPONSE" | jq '.'

            ESBUILD_INSTALL_STATUS=$(echo "$ESBUILD_INSTALL_ID_RESPONSE" | jq -r '.status')

            if [[ "$ESBUILD_INSTALL_STATUS" == "succeeded" ]]; then
              echo "esbuild install succeeded"
              exit 0
            elif [[ "$ESBUILD_INSTALL_STATUS" == "failed" ]]; then
              echo "esbuild install failed"
              exit 1
            else
              echo "Waiting for esbuild install to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "esbuild install is still in progress after 30 minutes. Exiting."
          echo "Final esbuild install Status: $ESBUILD_INSTALL_STATUS"
          exit 1

      # Render で JavaScript のバンドルジョブを実行
      # Render APIから js-bundleデータを取得
      # 変数JS_BUNDLE_JOB_RESPONSE が空ではないか確認
      # js-bundle ID を取得
      # 変数JS_BUNDLE_ID が空ではないか確認
      # 最大180回を js-bundle ID情報の取得を反復
      # Render API から js-bundle ID情報を取得
      # 変数JS_BUNDLE_ID_RESPONSE が空ではないか確認
      # js-bundle のステータスを取得
      # js-bundle のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run bundle js
        env:
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          JS_BUNDLE_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "./node_modules/.bin/esbuild app/javascript/*.* --bundle --sourcemap --outdir=public/assets"
            }')

            if [[ -z "$JS_BUNDLE_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve js bundle job information"
              exit 1
            fi

            echo "$JS_BUNDLE_JOB_RESPONSE" | jq '.'

            JS_BUNDLE_ID=$(echo "$JS_BUNDLE_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$JS_BUNDLE_ID" ]]; then
            echo "Failed to retrieve js-bundle-id information"
            exit 1
          fi

          echo "$JS_BUNDLE_ID"

          for i in {1..180}; do
            JS_BUNDLE_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$JS_BUNDLE_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$JS_BUNDLE_ID_RESPONSE" ]]; then
              echo "Failed to retrieve js bundle information"
              exit 1
            fi

            echo "$JS_BUNDLE_ID_RESPONSE" | jq '.'

            JS_BUNDLE_STATUS=$(echo "$JS_BUNDLE_ID_RESPONSE" | jq -r '.status')

            if [[ "$JS_BUNDLE_STATUS" == "succeeded" ]]; then
              echo "js bundle succeeded"
              exit 0
            elif [[ "$JS_BUNDLE_STATUS" == "failed" ]]; then
              echo "js bundle failed"
              exit 1
            else
              echo "Waiting for js bundle to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "js bundle is still in progress after 30 minutes. Exiting."
          echo "Final js bundle Status: $JS_BUNDLE_STATUS"
          exit 1

      # Render で css のバンドルジョブを実行
      # Render APIから css-bundleデータを取得
      # 変数CSS_BUNDLE_JOB_RESPONSE が空ではないか確認
      # css-bundle ID を取得
      # 変数CSS_BUNDLE_ID が空ではないか確認
      # 最大180回を css-bundle ID情報の取得を反復
      # Render API から css-bundle ID情報を取得
      # 変数CSS_BUNDLE_ID_RESPONSE が空ではないか確認
      # css-bundle のステータスを取得
      # css-bundle のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run bundle css
        env:
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          CSS_BUNDLE_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "./node_modules/.bin/esbuild app/assets/stylesheets/application.css --bundle --outdir=public/assets"
            }')

            if [[ -z "$CSS_BUNDLE_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve css bundle job information"
              exit 1
            fi

            echo "$CSS_BUNDLE_JOB_RESPONSE" | jq '.'

            CSS_BUNDLE_ID=$(echo "$CSS_BUNDLE_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$CSS_BUNDLE_ID" ]]; then
            echo "Failed to retrieve css-bundle-id information"
            exit 1
          fi

          echo "$CSS_BUNDLE_ID"

          for i in {1..180}; do
            CSS_BUNDLE_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$CSS_BUNDLE_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$CSS_BUNDLE_ID_RESPONSE" ]]; then
              echo "Failed to retrieve css bundle information"
              exit 1
            fi

            echo "$CSS_BUNDLE_ID_RESPONSE" | jq '.'

            CSS_BUNDLE_STATUS=$(echo "$CSS_BUNDLE_ID_RESPONSE" | jq -r '.status')

            if [[ "$CSS_BUNDLE_STATUS" == "succeeded" ]]; then
              echo "css bundle succeeded"
              exit 0
            elif [[ "$CSS_BUNDLE_STATUS" == "failed" ]]; then
              echo "css bundle failed"
              exit 1
            else
              echo "Waiting for css bundle to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "css bundle is still in progress after 30 minutes. Exiting."
          echo "Final css bundle Status: $CSS_BUNDLE_STATUS"
          exit 1

      # Render で Yarn のビルドを実行
      # Render APIから yarn-buildデータを取得
      # 変数YARN_BUILD_JOB_RESPONSE が空ではないか確認
      # yarn-build ID を取得
      # 変数YARN_BUILD_ID が空ではないか確認
      # 最大180回を yarn-build ID情報の取得を反復
      # Render API から yarn-build ID情報を取得
      # 変数YARN_BUILD_ID_RESPONSE が空ではないか確認
      # yarn-build のステータスを取得
      # yarn-build のステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run yarn build
        env:
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          YARN_BUILD_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "yarn build"
            }')

            if [[ -z "$YARN_BUILD_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve yarn build job information"
              exit 1
            fi

            echo "$YARN_BUILD_JOB_RESPONSE" | jq '.'

            YARN_BUILD_ID=$(echo "$YARN_BUILD_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$YARN_BUILD_ID" ]]; then
            echo "Failed to retrieve yarn-build-id information"
            exit 1
          fi

          echo "$YARN_BUILD_ID"

          for i in {1..180}; do
            YARN_BUILD_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$YARN_BUILD_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$YARN_BUILD_ID_RESPONSE" ]]; then
              echo "Failed to retrieve yarn build information"
              exit 1
            fi

            echo "$YARN_BUILD_ID_RESPONSE" | jq '.'

            YARN_BUILD_STATUS=$(echo "$YARN_BUILD_ID_RESPONSE" | jq -r '.status')

            if [[ "$YARN_BUILD_STATUS" == "succeeded" ]]; then
              echo "yarn build succeeded"
              exit 0
            elif [[ "$YARN_BUILD_STATUS" == "failed" ]]; then
              echo "yarn build failed"
              exit 1
            else
              echo "Waiting for yarn build to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "yarn build is still in progress after 30 minutes. Exiting."
          echo "Final yarn build Status: $YARN_BUILD_STATUS"
          exit 1

      # Render でアセットのプリコンパイルを実行
      # Render APIからプリコンパイルデータを取得
      # 変数PRECOMPILE_JOB_RESPONSE が空ではないか確認
      # プリコンパイルID を取得
      # 変数PRECOMPILE_ID が空ではないか確認
      # 最大180回をプリコンパイルID情報の取得を反復
      # Render API からプリコンパイルID情報を取得
      # 変数PRECOMPILE_ID_RESPONSE が空ではないか確認
      # プリコンパイルステータスを取得
      # プリコンパイルステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run assets precompile
        env:
          RAILS_ENV: production
          SECRET_KEY_BASE: ${{ secrets.SECRET_KEY_BASE }}
        run: |
          PRECOMPILE_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error \
            -d '{
              "startCommand": "bundle exec rails assets:precompile"
            }')

            if [[ -z "$PRECOMPILE_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve creating assets precompile job information"
              exit 1
            fi

            echo "$PRECOMPILE_JOB_RESPONSE" | jq '.'

            PRECOMPILE_ID=$(echo "$PRECOMPILE_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$PRECOMPILE_ID" ]]; then
            echo "Failed to retrieve assets-precompile-id information"
            exit 1
          fi

          echo "$PRECOMPILE_ID"

          for i in {1..180}; do
            PRECOMPILE_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$PRECOMPILE_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$PRECOMPILE_ID_RESPONSE" ]]; then
              echo "Failed to retrieve running assets precompile information"
              exit 1
            fi

            echo "$PRECOMPILE_ID_RESPONSE" | jq '.'

            PRECOMPILE_STATUS=$(echo "$PRECOMPILE_ID_RESPONSE" | jq -r '.status')

            if [[ "$PRECOMPILE_STATUS" == "succeeded" ]]; then
              echo "assets precompile succeeded"
              exit 0
            elif [[ "$PRECOMPILE_STATUS" == "failed" ]]; then
              echo "assets precompile failed"
              exit 1
            else
              echo "Waiting for assets precompile to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "Assets precompile is still in progress after 30 minutes. Exiting."
          echo "Final Assets precompile Status: $PRECOMPILE_STATUS"
          exit 1

      # public/assetsディレクトリにファイルが作成されているかを確認
      - name: Check assets precompile
        run: |
          if [ -d "public/assets" ] && [ "$(ls -A public/assets)" ]; then
            echo "Assets compiled successfully."
          else
            echo "Assets compilation failed or builds directory is empty."
            exit 1
          fi

      # Render API へデプロイ
      # Render API からのレスポンスを確認
      - name: Trigger Render Deployment
        run: |
          set -e
          POST_RESPONSE=$(curl -X POST \
          --verbose \
          -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"clearCache": true}' \
          https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys --fail --show-error)

          if [[ -z "$POST_RESPONSE" ]]; then
            echo "Failed to trigger deployment for service ID: ${{ secrets.RENDER_SERVICE_ID }}"
            exit 1
          else
            echo "Deployment POST response:$POST_RESPONSE"
          fi

      # 最大180回の反復を設定
      # Render API からデプロイ情報を取得
      # 変数GET_DEPROY_RESPONSE が空ではないか確認
      # レスポンス全体を表示してデバッグ情報を確認
      # 最新のデプロイ情報を取得
      # 変数LATEST_DEPLOY が空ではないか確認
      # デプロイID を取得
      # 変数RENDER_DEPLOY_ID が空ではないか確認
      # 変数RENDER_DEPLOY_ID を GITHUB_ENV に格納
      # デプロイステータスを取得
      # 変数RENDER_DEPLOY_STATUS が空でないか確認
      # ステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Check Render Deployment Status
        run: |
          set -e

          for i in {1..180}; do

            GET_DEPLOY_RESPONSE=$(curl -X GET \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$GET_DEPLOY_RESPONSE" ]]; then
              echo "Failed to retrieve deployment information"
              exit 1
            fi

            echo "$GET_DEPLOY_RESPONSE" | jq '.'

            LATEST_DEPLOY=$(echo "$GET_DEPLOY_RESPONSE" | jq -r 'map(.deploy) | sort_by(.createdAt) | last')

            if [[ -z "$LATEST_DEPLOY" ]]; then
              echo "Failed to retrieve the latest deploy"
              exit 1
            fi

            RENDER_DEPLOY_ID=$(echo "$LATEST_DEPLOY" | jq -r '.id')
            if [[ -z "$RENDER_DEPLOY_ID" ]]; then
              echo "Failed to extract deployment details"
              exit 1
            else
              echo "Render Deploy ID: $RENDER_DEPLOY_ID"
              echo "RENDER_DEPLOY_ID=$RENDER_DEPLOY_ID" >> $GITHUB_ENV
            fi

            RENDER_DEPLOY_STATUS=$(echo "$LATEST_DEPLOY" | jq -r '.status')
            if [[ -z "$RENDER_DEPLOY_STATUS" ]]; then
              echo "Failed to retrieve deployment status"
              exit 1
            elif [[ "$RENDER_DEPLOY_STATUS" == "build_failed" ]]; then
              echo "Deployment build_failed!"
              exit 1
            elif [[ "$RENDER_DEPLOY_STATUS" == "update_failed" ]]; then
              echo "Deployment update_failed!"
              exit 1
            elif [[ "$RENDER_DEPLOY_STATUS" == "canceled" ]]; then
              echo "Deployment canceled!"
              exit 1
            elif [[ "$RENDER_DEPLOY_STATUS" == "live" ]]; then
              echo "Deployment live!"
              exit 0
            fi

            sleep 10
          done

          echo "Deployment is still in progress after 30 minutes. Exiting."
          echo "Final Deployment Status: $RENDER_DEPLOY_STATUS"
          exit 1

      # Render の PostgreSQL に初期データを挿入
      # Render APIからマイグレーションデータを取得
      # 変数MIGRATION_JOB_RESPONSE が空ではないか確認
      # マイグレーションID を取得
      # 変数MIGRATION_ID が空ではないか確認
      # 最大180回をマイグレーションID情報の取得を反復
      # Render API からマイグレーションID情報を取得
      # 変数MIGRATION_ID_RESPONSE が空ではないか確認
      # マイグレーションステータスを取得
      # マイグレーションステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run Database Migration on Render
        run: |
          MIGRATION_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error\
            -d '{
              "startCommand": "bundle exec rails db:migrate"
            }')

          if [[ -z "$MIGRATION_JOB_RESPONSE" ]]; then
            echo "Failed to retrieve creating migration job information"
            exit 1
          fi

          echo "$MIGRATION_JOB_RESPONSE" | jq '.'

          MIGRATION_ID=$(echo "$MIGRATION_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$MIGRATION_ID" ]]; then
            echo "Failed to retrieve migration-id information"
            exit 1
          fi

          echo "$MIGRATION_ID"

          for i in {1..180}; do
            MIGRATION_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$MIGRATION_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$MIGRATION_ID_RESPONSE" ]]; then
              echo "Failed to retrieve running migration information"
              exit 1
            fi

            echo "$MIGRATION_ID_RESPONSE" | jq '.'

            MIGRATION_STATUS=$(echo "$MIGRATION_ID_RESPONSE" | jq -r '.status')

            if [[ "$MIGRATION_STATUS" == "succeeded" ]]; then
              echo "Migration succeeded"
              exit 0
            elif [[ "$MIGRATION_STATUS" == "failed" ]]; then
              echo "Migration failed"
              exit 1
            else
              echo "Waiting for migration to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "Migration is still in progress after 30 minutes. Exiting."
          echo "Final migration Status: $MIGRATION_STATUS"
          exit 1

      # Render の PostgreSQL に初期データを挿入
      # Render APIからシードデータを取得
      # 変数SEED_JOB_RESPONSE が空ではないか確認
      # シードID を取得
      # 変数SEED_ID が空ではないか確認
      # 最大180回をシードID情報の取得を反復
      # Render API からシードID情報を取得
      # 変数SEED_ID_RESPONSE が空ではないか確認
      # シードステータスを取得
      # シードステータスを判定
      # 10秒待機しステータスの判定を反復
      - name: Run Database Seed on Render
        run: |
          SEED_JOB_RESPONSE=$(curl -X POST \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error\
            -d '{
              "startCommand": "bundle exec rails db:seed"
            }')

            if [[ -z "$SEED_JOB_RESPONSE" ]]; then
              echo "Failed to retrieve creating seed job information"
              exit 1
            fi

            echo "$SEED_JOB_RESPONSE" | jq '.'

          SEED_ID=$(echo "$SEED_JOB_RESPONSE" | jq -r '.id')

          if [[ -z "$SEED_ID" ]]; then
            echo "Failed to retrieve seed-id information"
            exit 1
          fi

          echo "$SEED_ID"

          for i in {1..180}; do
            SEED_ID_RESPONSE=$(curl -X GET \
              "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/jobs/$SEED_ID" \
              -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
              -H "Content-Type: application/json" --fail --show-error)

            if [[ -z "$SEED_ID_RESPONSE" ]]; then
              echo "Failed to retrieve running seed information"
              exit 1
            fi

            echo "$SEED_ID_RESPONSE" | jq '.'

            SEED_STATUS=$(echo "$SEED_ID_RESPONSE" | jq -r '.status')

            if [[ "$SEED_STATUS" == "succeeded" ]]; then
              echo "Seed succeeded"
              exit 0
            elif [[ "$SEED_STATUS" == "failed" ]]; then
              echo "Seed failed"
              exit 1
            else
              echo "Waiting for seed to complete... (attempt $i/180)"
              sleep 10
            fi
          done

          echo "Seed is still in progress after 30 minutes. Exiting."
          echo "Final Seed Status: $SEED_STATUS"
          exit 1
