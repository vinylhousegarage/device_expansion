name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    timeout-minutes: 60

    steps:
      # リモートリポジトリをチェックアウト
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # 実行中のユーザーを確認
      - name: Check current user
        run: whoami

      # ls -ld コマンドを実行して、ディレクトリの所有者とパーミッションを確認
      - name: Check directory permissions and ownership
        run: ls -ld /home/runner/work/device_expansion/device_expansion

      # ディレクトリ内のパーミッションの確認
      - name: Check permissions of all files
        run: ls -lR /home/runner/work/device_expansion/device_expansion

      # GHCR にログイン
      - name: Log in to GitHub Container Registry
        run: |
          echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      # GHCRから既存のDockerイメージをプルしてキャッシュとして使用
      - name: Pull Docker image from GHCR
        run: docker pull ghcr.io/vinylhousegarage/device_expansion:latest || echo "No cached image found, continuing with fresh build"

      # Dockerイメージ に差分があるコミットを commit_list.txt に抽出
      - name: Get commits with Dockerfile or compose.yaml changes
        run: |
          git log --reverse --pretty=format:"%H" $HEAD -- Dockerfile compose.yaml .github/workflows/ci.yml > commit_list.txt
          if [ ! -s commit_list.txt ]; then
            echo "No commits with Dockerfile or compose.yaml changes found."
            exit 0
          fi

      # commit_list.txt のコミットIDを1行ずつ読み取り GHCR にビルドしプッシュ
      # 最新のコミットを変数LATEST_COMMIT に格納
      # 変数LATEST_COMMIT が空ではないか確認
      # 最新のDockerイメージに latest のタグを付けGHCRにビルドしプッシュ
      - name: Process each commit
        run: |
          set -e
          echo "Commits to process: $(cat commit_list.txt)"
          while IFS= read -r COMMIT; do
            echo "Processing commit: $COMMIT with message: $(git log -1 --pretty=%B $COMMIT)"
            docker build --cache-from ghcr.io/vinylhousegarage/device_expansion:latest \
            -t ghcr.io/vinylhousegarage/device_expansion:$COMMIT .
            docker push ghcr.io/vinylhousegarage/device_expansion:$COMMIT
            LATEST_COMMIT=$COMMIT
          done < commit_list.txt

          if [[ -n "$LATEST_COMMIT" ]]; then
            docker tag ghcr.io/vinylhousegarage/device_expansion:$LATEST_COMMIT ghcr.io/vinylhousegarage/device_expansion:latest
            docker push ghcr.io/vinylhousegarage/device_expansion:latest
          fi

      # Ruby をセットアップ
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.1.0

      # Gem のキャッシュを利用してビルドを高速化
      - name: Cache gems
        uses: actions/cache@v3
        with:
          path: vendor/bundle
          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}-v1
          restore-keys: |
            ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}-v1
            ${{ runner.os }}-gems-v1

      # PostgreSQL 関連のライブラリと gem をインストール
      - name: Install dependencies
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y libpq-dev || echo "Failed to install libpq-dev"
          bundle config set path 'vendor/bundle'
          bundle install --jobs 4 --retry 3

      # RuboCop を実行してコードスタイルを検証
      - name: Run RuboCop (Lint check)
        run: bundle exec rubocop --config .rubocop.yml --fail-level W

      # PostgreSQL と postgresql-client を 14 でインストール
      - name: Install PostgreSQL 14 and client tools
        run: |
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          sudo apt-get update
          sudo apt-get install -y postgresql-14 postgresql-client-14
          sudo service postgresql start

      # 最大60秒間 PostgreSQL の応答を確認
      - name: Wait for PostgreSQL to be ready
        run: |
          for i in {1..12}; do
            if pg_isready -h localhost -p 5432; then
              echo "PostgreSQL is ready!"
              exit 0
            fi
            echo "Waiting for PostgreSQL to be ready... Attempt $i at $(date)"
            sleep 5
          done
          echo "PostgreSQL did not become ready in time."
          exit 1

      # ユーザーロールをセットアップ
      - name: Set up pg_role
        run: |
          if ! sudo -u postgres psql -tc "SELECT 1 FROM pg_roles WHERE rolname='${{ secrets.POSTGRES_USER }}'" | grep -q 1; then
            sudo -u postgres psql -c "CREATE USER ${{ secrets.POSTGRES_USER }} WITH PASSWORD '${{ secrets.POSTGRES_PASSWORD }}';" || exit 1
          fi

      # データベースへの権限を付与
      - name: Set up db privileges
        run: |
          sudo -u postgres psql -c "GRANT SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES ON ALL TABLES IN SCHEMA public TO ${{ secrets.POSTGRES_USER }};" || exit 1
          sudo -u postgres psql -c "ALTER USER ${{ secrets.POSTGRES_USER }} WITH CREATEDB;" || exit 1

      # データベースの有無を確認
      - name: List all databases with expanded output
        run: |
          echo "Listing all databases in expanded mode:"
          sudo -u postgres psql -c "\l"

      # デーベースの名前を確認
      - name: List all database names
        run: |
          echo "Listing all database names in PostgreSQL:"
          sudo -u postgres psql -c "SELECT datname FROM pg_database;"

      # データベースが存在していた場合は削除
      - name: Drop existing database
        run: |
          sudo -u postgres psql -c "DROP DATABASE IF EXISTS ${{ secrets.POSTGRES_DB }};" || exit 1

      # データベースの削除を確認
      - name: Confirm database deletion
        run: |
          echo "Confirming that the database has been deleted:"
          sudo -u postgres psql -c "\l"
          echo "If the database name is not listed above, the deletion was successful."

      # ジョブの強制終了
      - name: Stop the job
        run: exit 1

      # POSTGRES_DB を生成
      - name: Run database create
        env:
          TEST_DB: ${{ secrets.POSTGRES_DB }}
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:create RAILS_ENV=test

      # POSTGRES_DB をマイグレート
      - name: Run database migrations
        env:
          TEST_DB: ${{ secrets.POSTGRES_DB }}
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:migrate RAILS_ENV=test

      # マイグレートした POSTGRES_DB に初期データを挿入
      - name: Run Seed the test database
        env:
          TEST_DB: ${{ secrets.POSTGRES_DB }}
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails db:seed RAILS_ENV=test

      # テストを実行
      - name: Run tests
        env:
          TEST_DB: ${{ secrets.POSTGRES_DB }}
          TEST_USER: ${{ secrets.POSTGRES_USER }}
          TEST_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: bundle exec rails test RAILS_ENV=test

  deploy:
    runs-on: ubuntu-latest
    needs: build
    env:
      RAILS_ENV: production

    steps:
      # リモートリポジトリをチェックアウト
      - name: Check out the repository
        uses: actions/checkout@v3

      # mainブランチへのマージをトリガーとして Render API へデプロイ
      # デプロイキャッシュはクリアしない設定
      # Render API からのレスポンスを確認
      - name: Trigger Render Deployment
        run: |
          set -e
          POST_RESPONSE=$(curl -X POST \
          --verbose \
          -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"clearCache":false}' \
          https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys --fail --show-error)

          if [[ -z "$POST_RESPONSE" ]]; then
            echo "Failed to trigger deployment for service ID: ${{ secrets.RENDER_SERVICE_ID }}"
            exit 1
          else
            echo "Deployment POST response:$POST_RESPONSE"
          fi

      # jqをインストール
      - name: Install jq
        run: sudo apt-get install -y jq

      # Render API からデプロイ情報を取得
      # Render API からのレスポンスを確認
      # 変数 GET_RESPONSE が空ではないかを確認し、GITHUB_ENV に格納
      - name: Get latest Render Deploy records
        run: |
          set -e
          GET_RESPONSE=$(curl -X GET \
          --verbose \
          "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys" \
          -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
          -H "Content-Type: application/json" --fail --show-error)

          if [[ -z "$GET_RESPONSE" ]]; then
            echo "Failed to trigger deployment"
            exit 1
          else
            echo "Deployment GET response:$GET_RESPONSE"
            echo "GET_RESPONSE=$GET_RESPONSE" >> $GITHUB_ENV
          fi

      # デプロイ情報を確認し、変数RENDER_DEPLOY_ID と 変数RENDER_DEPLOY_STATUS に格納
      # 変数が空ではないかを確認し、GITHUB_ENV に格納
      - name: Extract Deployment ID and Status
        run: |
          LATEST_DEPLOY=$(echo "$GET_RESPONSE" | jq -r '. | sort_by(.createdAt) | last')
          if [[ -z "$LATEST_DEPLOY" ]]; then
            echo "Failed to retrieve the latest deploy"
            exit 1
          fi

          RENDER_DEPLOY_ID=$(echo "$LATEST_DEPLOY" | jq -r '.id')
          if [[ -z "$RENDER_DEPLOY_ID" ]]; then
            echo "Failed to extract deployment details"
            exit 1
          else
            echo "Render Deploy ID: $RENDER_DEPLOY_ID"
            echo "RENDER_DEPLOY_ID=$RENDER_DEPLOY_ID" >> $GITHUB_ENV
          fi

          RENDER_DEPLOY_STATUS=$(echo "$LATEST_DEPLOY" | jq -r '.status')
          if [[ -z "$RENDER_DEPLOY_STATUS" ]]; then
            echo "Failed to retrieve deployment status"
            exit 1
          else
            echo "Render Deploy Status: $RENDER_DEPLOY_STATUS"
            echo "RENDER_DEPLOY_STATUS=$RENDER_DEPLOY_STATUS" >> $GITHUB_ENV
          fi

      # デプロイステータスが "succeeded" かどうか確認
      - name: Check Deployment Status
        run: |
          if [[ "$RENDER_DEPLOY_STATUS" != "succeeded" ]]; then
            echo "Deployment failed with status: $RENDER_DEPLOY_STATUS"
            exit 1
          else
            echo "Deployment succeeded with status: $RENDER_DEPLOY_STATUS"
          fi

      # Render の PostgreSQL をマイグレート
      - name: Run migration on Render
        run: |
          set -e
          curl -X POST \
          --verbose \
          -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"command": "rails db:migrate"}' \
          https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/ssh --fail --show-error

      # Render の PostgreSQL に初期データを挿入
      - name: Run seed on Render
        run: |
          set -e
          curl -X POST \
          --verbose \
          -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
          -H "Content-Type: application/json" \
          -d '{"command": "rails db:seed"}' \
          https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/ssh --fail --show-error

      # 最新デプロイのログを取得
      - name: Log Render Deploy ID & Get Logs
        run: |
          set -e
          if [[ -z "$RENDER_DEPLOY_ID" ]]; then
            echo "Failed to retrieve Render Deploy ID. Deployment may not have been triggered correctly."
            exit 1
          else
            echo "Render Deploy ID: $RENDER_DEPLOY_ID"
            curl -X GET \
            --verbose \
            "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys/$RENDER_DEPLOY_ID/logs" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" --fail --show-error
          fi
        timeout-minutes: 10
